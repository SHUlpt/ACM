## 字典树(Trie)

### 应用

1. 字符串检索：在$n$个字符串中检索、查询某个字符串
2. 词频统计：统计一个单词出现了多少次
3. 字符串排序：在插入的时候，在树的平级按字典序插入。字典树建好后，用先序遍历就能得到字典树的排序
4. 前缀匹配：字典树是按照公共前缀来建树，适合用于搜索提示

### 模板

数组存储字典树



```c++
const int maxn = 1e6 + 10;
int trie[maxn][26];	// 用数组定义字典树，存储下一个字符的位置
bool exist[maxn];   // 该结点为结尾的字符串是否存在
int cnt = 1;		// 当前新结点的存储位置
void Insert(string s) {
    int p = 0;
    for (int i = 0; i < s.size(); i++) {jiedian
        int c = s[i] - 'a';
        if (!trie[p][c]) trie[p][c] = cnt++;
        p = trie[p][c];
    }
    exist[p] = 1;
}
bool Find(string s) {
    int p = 0;
    for (int i = 0; i < s.size(); i++) {
        int c = s[i] - 'a';
        if (!trie[p][c]) return 0;
        p = trie[p][c];
    }
    return exist[p];
} 
```





```c++
const int maxn = 1e6 + 10;
int trie[maxn][26];
int num[maxn];
int pos = 1;
void Insert(string s)
{
    int p = 0;
    for (int i = 0; i < s.size(); i++) {
        int n = s[i] - 'a';
        if (trie[p][n] == 0) {
            trie[p][n] = pos++;
        }
        p = trie[p][n];
        num[p]++;
    }
}
int Find(string s)
{
    int p = 0;
    for (int i = 0; i < s.size(); i++) {
        int n = s[i] - 'a';
        if (trie[p][n] == 0) return 0;
        p = trie[p][n];
    }
    return num[p];
}
```

